
> (load "../compile-tr.lisp")

T
> (compile-tr "corner-notr.ded" '(V))
File created at raised-lex-rules.ded
The rules also set to the global variable *RAISED-LEX-RULES*
NIL
> (save-compile "corner-new.ded")
Grammar added at the end of *ccg-grammar*
NIL
> (lg "corner-new.ded")

======================= l o a d i n g =======================================

**ERROR loading the project corner-new.ded.
  A required corner-new.ded file does not exist or corner-new.ded.ccg has syntax error.
  Have a look at corner-new.ded.ded to see if there is error in corner-new.ded.ccg.
Project corner-new.ded cannot be loaded:
  *ccg-grammar* is unchanged.
  *lex-rules-table* is unchanged.
NIL
> (lg "corner-new")

======================= l o a d i n g =======================================

Project [corner-new] is assumed to consist of
-----------------------------------------------------------------------------
  CCG grammar source : corner-new.ccg $
    Its token form   : corner-new.lisptokens $
  Deduction grammar  : corner-new.ded $ (derived from corner-new.lisptokens)
  Induction grammar  : corner-new.ind #
  Supervision source : corner-new.sup ^
  Model-specific code: corner-new.lisp ^
   and other model-specific files you may create.
       *CCG-GRAMMAR* : set from corner-new.ded
  *LEX-RULES-TABLE*  : set from corner-new.ded
Expected files       : $ for deduction, # for induction, ^ for model development
=============================================================================
T
> (type-raise-off)

NIL
> (p '(the man hits the man))

T
> (ders)


Derivation 1
--------------
LEX   (THE) := NP/*N
        : (LAM X X)
LEX   (MAN) := N
        : MAN
>     (THE)(MAN) := NP
        : ((LAM X X) MAN)
LEX   (HITS) := (S\NP)/NP
        : (LAM X (LAM Y ((HITS X) Y)))
LEX   (THE) := NP/*N
        : (LAM X X)
LEX   (MAN) := N
        : MAN
>     (THE)(MAN) := NP
        : ((LAM X X) MAN)
>     (HITS)(THE MAN) := S\NP
        : ((LAM X (LAM Y ((HITS X) Y))) ((LAM X X) MAN))
<     (THE MAN)(HITS THE MAN) := S
        : (((LAM X (LAM Y ((HITS X) Y))) ((LAM X X) MAN)) ((LAM X X) MAN))

Final LF, normal-order evaluated: 

    ((HITS MAN) MAN) =
    (HITS MAN MAN)

Derivation 2
--------------
LEX   (THE) := NP/*N
        : (LAM X X)
LEX   (MAN) := N
        : MAN
>     (THE)(MAN) := NP
        : ((LAM X X) MAN)
LEX   (THE) := NP/*N
        : (LAM X X)
LEX   (MAN) := N
        : MAN
>     (THE)(MAN) := NP
        : ((LAM X X) MAN)
LEX   (HITS) := (S\NP)/NP
        : (LAM X (LAM Y ((HITS X) Y)))
auto-tr-747 (THE MAN) := (S\NP)\((S\NP)/NP)
        : ((LAM LF (LAM P (P LF))) ((LAM X X) MAN))
<     (HITS)(THE MAN) := S\NP
        : (((LAM LF (LAM P (P LF))) ((LAM X X) MAN))
           (LAM X (LAM Y ((HITS X) Y))))
<     (THE MAN)(HITS THE MAN) := S
        : ((((LAM LF (LAM P (P LF))) ((LAM X X) MAN))
            (LAM X (LAM Y ((HITS X) Y))))
           ((LAM X X) MAN))

Final LF, normal-order evaluated: 

    ((HITS MAN) MAN) =
    (HITS MAN MAN)

Derivation 3
--------------
LEX   (THE) := NP/*N
        : (LAM X X)
LEX   (MAN) := N
        : MAN
>     (THE)(MAN) := NP
        : ((LAM X X) MAN)
auto-tr-746 (THE MAN) := S/(S\NP)
        : ((LAM LF (LAM P (P LF))) ((LAM X X) MAN))
LEX   (HITS) := (S\NP)/NP
        : (LAM X (LAM Y ((HITS X) Y)))
LEX   (THE) := NP/*N
        : (LAM X X)
LEX   (MAN) := N
        : MAN
>     (THE)(MAN) := NP
        : ((LAM X X) MAN)
>     (HITS)(THE MAN) := S\NP
        : ((LAM X (LAM Y ((HITS X) Y))) ((LAM X X) MAN))
>     (THE MAN)(HITS THE MAN) := S
        : (((LAM LF (LAM P (P LF))) ((LAM X X) MAN))
           ((LAM X (LAM Y ((HITS X) Y))) ((LAM X X) MAN)))

Final LF, normal-order evaluated: 

    ((HITS MAN) MAN) =
    (HITS MAN MAN)

Derivation 4
--------------
LEX   (THE) := NP/*N
        : (LAM X X)
LEX   (MAN) := N
        : MAN
>     (THE)(MAN) := NP
        : ((LAM X X) MAN)
LEX   (THE) := NP/*N
        : (LAM X X)
LEX   (MAN) := N
        : MAN
>     (THE)(MAN) := NP
        : ((LAM X X) MAN)
auto-tr-746 (THE MAN) := S/(S\NP)
        : ((LAM LF (LAM P (P LF))) ((LAM X X) MAN))
LEX   (HITS) := (S\NP)/NP
        : (LAM X (LAM Y ((HITS X) Y)))
auto-tr-747 (THE MAN) := (S\NP)\((S\NP)/NP)
        : ((LAM LF (LAM P (P LF))) ((LAM X X) MAN))
<     (HITS)(THE MAN) := S\NP
        : (((LAM LF (LAM P (P LF))) ((LAM X X) MAN))
           (LAM X (LAM Y ((HITS X) Y))))
>     (THE MAN)(HITS THE MAN) := S
        : (((LAM LF (LAM P (P LF))) ((LAM X X) MAN))
           (((LAM LF (LAM P (P LF))) ((LAM X X) MAN))
            (LAM X (LAM Y ((HITS X) Y)))))

Final LF, normal-order evaluated: 

    ((HITS MAN) MAN) =
    (HITS MAN MAN)

Try (cky-pprint) to see the details including the features and slash modalities.
    (cky-reveal-cell <cell>) to pretty-print the parse in <cell>.
NIL
> (type-raise-on)

Your list of arguments to type raise is nil.
Call type-raise-targets to set it.
NIL
> (type-raise-targets '(NP))

(NP)
> (p '(the man hits the man))

T
> (ders)


Derivation 1
--------------
LEX   (THE) := NP/*N
        : (LAM X X)
LEX   (MAN) := N
        : MAN
>     (THE)(MAN) := NP
        : ((LAM X X) MAN)
LEX   (THE) := NP/*N
        : (LAM X X)
LEX   (MAN) := N
        : MAN
>     (THE)(MAN) := NP
        : ((LAM X X) MAN)
auto-tr-746 (THE MAN) := S/(S\NP)
        : ((LAM LF (LAM P (P LF))) ((LAM X X) MAN))
LEX   (HITS) := (S\NP)/NP
        : (LAM X (LAM Y ((HITS X) Y)))
auto-tr-747 (THE MAN) := (S\NP)\((S\NP)/NP)
        : ((LAM LF (LAM P (P LF))) ((LAM X X) MAN))
<     (HITS)(THE MAN) := S\NP
        : (((LAM LF (LAM P (P LF))) ((LAM X X) MAN))
           (LAM X (LAM Y ((HITS X) Y))))
>     (THE MAN)(HITS THE MAN) := S
        : (((LAM LF (LAM P (P LF))) ((LAM X X) MAN))
           (((LAM LF (LAM P (P LF))) ((LAM X X) MAN))
            (LAM X (LAM Y ((HITS X) Y)))))

Final LF, normal-order evaluated: 

    ((HITS MAN) MAN) =
    (HITS MAN MAN)

Try (cky-pprint) to see the details including the features and slash modalities.
    (cky-reveal-cell <cell>) to pretty-print the parse in <cell>.
NIL
> (dribble)
